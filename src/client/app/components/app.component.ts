/*
 * Copyright (c) 2017.
 *
 *   This program is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import {
  AfterViewInit,
  ChangeDetectionStrategy, Component, ElementRef, Inject, Input, OnDestroy, OnInit,
  ViewChild
} from '@angular/core';
import {ActivatedRoute, NavigationEnd, NavigationStart, Router} from '@angular/router';
import {
  DOCUMENT, isPlatformBrowser, Location, LocationStrategy, PathLocationStrategy
} from '@angular/common';
import {MatSidenav} from '@angular/material';
import {MenuInteractionService} from '../services/menu/menu-interaction.service';
import {Store} from '@ngrx/store';
import * as fromRoot from '../reducers';
import {MediaChange, ObservableMedia} from '@angular/flex-layout';
import {Subscription} from 'rxjs/Subscription';
import {SetTimeoutService} from '../services/timers/timeout.service';
import {SetSelectedService} from '../services/set-selected.service';
import {Observable} from 'rxjs/Observable';
import {AreasFilter} from '../shared/data-types/areas-filter';
import {NavigationServiceB} from '../services/navigation-2/navigation.service';
import {SelectedAreaEvent} from './area-selector/area.component';
import {TypesFilter} from '../shared/data-types/types-filter';
import {AreaFilterType} from '../shared/data-types/area-filter.type';
import {TypesFilterType} from '../shared/data-types/types-filter.type';
import {LoggerService} from '../shared/logger/logger.service';

/**
 * This component includes the md-sidenav-container, md-sidenav
 * and the router outlet.
 *
 * The component is responsible for setting the scrollTop value
 * of the scrollable element generated by the md-sidenav-container
 * directive. This assures that list views and item views (which are
 * siblings of the router-outlet inside md-sidenav-container) are
 * positioned correctly on load.
 */
@Component({
  selector: 'app-root',
  templateUrl: 'app.component.html',
  styleUrls: ['app.component.css'],
  providers: [Location, {provide: LocationStrategy, useClass: PathLocationStrategy}],
  changeDetection: ChangeDetectionStrategy.Default
})
export class AppComponent implements AfterViewInit, OnInit, OnDestroy {

  watcher: Subscription;
  areaFilter$: Observable<AreasFilter>;
  selectedAreas: string;
  selectedTypes: string;
  selectedSubject: string;
  selectedGroup: string;
  homeUrl = 'http://libmedia.willamette.edu/academiccommons';
  secondaryUrl = 'http://library.willamette.edu';
  tertiaryUrl = 'http://www.willamette.edu';
  @ViewChild('sidenav') sideNavigate: MatSidenav;
  @ViewChild('appcontent') appContent: ElementRef;

  scrollable: Element;
  state = '';
  /**
   * The y scroll stack tracks the top of the collection view
   * element.  The measurement is obtained from the bounding
   * client rectangle of the #appContent child view and is used
   * to set the scrollTop for the scrollable div (cdk-scrollable)
   * created by the mdSidenavContainer directive (Angular Material).
   * @type {Array}
   */
  yScrollStack: number[] = [];

  constructor(private store: Store<fromRoot.State>,
              private menuService: MenuInteractionService,
              public media: ObservableMedia,
              private router: Router,
              private route: ActivatedRoute,
              @Inject(DOCUMENT) private document,
              private timeoutService: SetTimeoutService,
              private setSelected: SetSelectedService,
              private navigation: NavigationServiceB,
              private logger: LoggerService ) {

    this.watcher = new Subscription();
    const mediaWatcher = media.asObservable()
      .subscribe((change: MediaChange) => {
        this.state = change ? `'${change.mqAlias}' = (${change.mediaQuery})` : '';
      });
    this.watcher.add(mediaWatcher);

  }

  // onDeactivate(event) {
  // Chrome canary supports the new standard usage with documentElement, but
  // Chrome and presumably other browsers still expect body.
  // this.renderer.setProperty(this.document.body, 'scrollTop', 0);
  // this.renderer.setProperty(this.document.documentElement, 'scrollTop', 0);
  // }

  goToHome(): void {
    document.location.href = this.homeUrl;
  }

  goToSecondary(): void {
    document.location.href = this.secondaryUrl;
  }

  goToTertiary(): void {
    document.location.href = this.tertiaryUrl;
  }

  areaNavigation(updatedAreaList: SelectedAreaEvent): void {
    this.sideNavigate.close();
    const areaIds = this.navigation.getIds(updatedAreaList.selected);
    this.navigation.navigateFilterRoute(areaIds, this.selectedTypes, this.selectedSubject, this.selectedGroup);
  }

  ngOnInit() {

    const areaList = this.store.select(fromRoot.getAreas);
    const areaFilters = this.store.select(fromRoot.getAreasFilter);
    this.areaFilter$ = Observable.combineLatest(
      areaList,
      areaFilters,
      (areas, selected) => {
        this.selectedAreas = this.navigation.getIds(areas);
        return {
          areas: areas,
          selectedAreas: selected
        }
      }
    );
    const typeQuery: Subscription = this.store.select(fromRoot.getTypesFilter).subscribe(
      types => this.selectedTypes = this.navigation.getIds(types),
      err => console.log(err));
    this.watcher.add(typeQuery);

// Remove temporarily...subjects is now an array!
    // const subjectQuery: Subscription = this.store.select(fromRoot.getSubjectsFilter).subscribe(
    //   subject => this.selectedSubject = subject.id.toString(),
    //   err => console.log(err));
    // this.watcher.add(subjectQuery);

    const openWatcher = this.menuService.openMenu$.subscribe(open => {
      this.sideNavigate.open().catch((err) => {
        console.log(err);
      });
    });
    this.watcher.add(openWatcher);
  }

  ngAfterViewInit() {

    // Anticipating angular universal.
    if (isPlatformBrowser) {
      /**
       * This sets the scrollTop position for navigation between views.
       */
      this.router.events.subscribe((event: any) => {
        // Get the scrollable element (created by MdSidenavContainer)
        this.scrollable = this.document.querySelector('.mat-drawer-content');
        if (event instanceof NavigationStart) {
          // Get absolute value fo the bounding rectangle for #app-content.
          const top = Math.abs(this.appContent.nativeElement.getBoundingClientRect().top);

          // Push the value onto the y stack if the url is for an item view and the previous
          // route transition was not also to an item view. This effectively limits
          // y scroll value tracking to the collection view.
          if (event.url.match(/\/commons\/item/) && this.yScrollStack.length === 0) {
            // Push the top
            this.yScrollStack.unshift(top);
            this.logger.info('Bounding rectangle: ' + top);
            this.scrollable.scrollTop = 0;
          }
        } else if (event instanceof NavigationEnd) {
          // Use time out to push this work onto the browser's callback queue.
          // This allows rendering to complete before setting scrollTop.
          // If set to a value greater than the maximum available for the element,
          // scrollTop settles itself to the maximum value and we don't see the
          // desired result.
          this.timeoutService.setTimeout(500, () => {
            if (event.url.match(/\/commons\/collection/) && this.yScrollStack.length > 0) {
              const top = this.yScrollStack.pop();
              this.logger.info('setting scrollTop to: ' + top);
              // Pop the top
              this.scrollable.scrollTop = top;
            } else {
              // Currently the only other view is for items. This
              // view should always initialize with scrollTop equal
              // to zero.
              this.scrollable.scrollTop = 0;
            }
          });
        }
      });
    }
  }

  ngOnDestroy() {
    if (this.watcher) {
      this.watcher.unsubscribe();
    }
    if (this.timeoutService) {
      this.timeoutService.clearTimeout();
    }
    // Unsubscribe all watchers in the service. Each component
    // instance will resubscribe. The prevents the multiple
    // subscriptions within service.
    this.setSelected.unsubscribe();
  }


}
